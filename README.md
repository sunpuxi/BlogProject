在线访问地址： http://codefriends.icu，前端 UI 设计为移动端，手机访问体验更佳~


项目亮点：
Redis 缓存：减小数据库的压力，并提高响应速度。
Redisson 分布式锁：保证高并发情况下的数据的安全性与一致性。
缓存预热：使用定时任务进行缓存预热，提高缓存的可靠性。
自定义注解实现部分接口的限流。限流算法使用的 Guava 的 RateLimiter 的令牌限流算法。

-为什么使用 Redis 作为缓存？
Redis 的性能很高，并且可以作为分布式缓存。相比于 caffeine 有更强的可扩展空间。

-为什么使用分布式锁？
在 Java 代码中的 synchronized 或者其它锁的 API，都与本机的 JVM 绑定，如果是分布式系统，那么锁失效。
并且 synchronized 在并发量较大的情况下，会升级为重量级锁，性能较低。
采用 Redisson 实现的分布式锁则可以有效的解决以上两个痛点。

-如何保证数据库与缓存的双写一致性？
先来想两个场景：
1、如果先删除缓存，再更新数据库会产生什么问题？
   删除缓存之后，如果此时数据库的数据还没有更新完毕，那么会导致用户读取到的脏数据再次被加载到缓存中。

2、如果先更新数据库，再删除缓存会产生什么问题？
   先更新数据库的时候，如果数据库还没有更新完毕，或者更新数据库之后，还没有来得及删除缓存，此时有请求到达后端，那么请求到的数据还是为脏数据。

解决思路：使用延迟双删策略，先删除一次缓存，然后更新数据库，这时候可以让线程休眠一定的时间（取决于你的业务），之后再去删除一次缓存。
